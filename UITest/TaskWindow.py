# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TaskWindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import datetime
import os
import sys

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QSize, Qt, QThreadPool
from PyQt5.QtGui import QCursor
from PyQt5.QtWidgets import QMainWindow, QListWidgetItem, QMenu, QAction, QMessageBox

import DataEncrypt
import TaskExporter
import TaskImporter
import TestFlow

from ControlWindow import get_task_cell, TaskEntity, TaskCellWrap
from DataImportDialog import DataImportDialog
from TaskCreateWindow import TaskCreateDialog, TaskCreateEntity, rm_task_flow

# 数据库连接池
from TaskWorker import TaskWorker, TaskWorkerDispatcher
from database.Database import DataBasePool


def alert_msg(parent, msg):
    QMessageBox.about(parent, '温馨提示', msg)


mysql_pool = DataBasePool(host='localhost', port=3306, user='root', password='abc123456', db='load_emu')


def start_task(tid, start):
    sql = f'update t_task set is_running={start} where id={tid};'
    mysql_pool.execute(sql)


def rm_task(tid):
    sql = f'delete from t_task where id={tid};'
    mysql_pool.execute(sql)

    rm_task_flow(tid)


def dict_to_task(dic0: dict):
    create_time: datetime.datetime = dic0['create_time']
    ctime = create_time.strftime('%Y-%m-%d %H:%M:%S')

    entity = TaskEntity(tid=dic0['id'], name=dic0['task_name'], create_time=ctime,
                        proxy_ip=dic0['proxy_host'],
                        port=dic0['proxy_port'],
                        task_url=dic0['url'], profile_id=dic0['profile_id'], total_success_num=dic0['success_num'],
                        total_do_num=dic0['do_num'],
                        today_success_num=0, today_do_num=0, is_running=dic0['is_running'])
    return entity


def query_task_by_tid(tid):
    sql = f'select * from t_task where id={tid};'
    rests = mysql_pool.query(sql)
    c = len(rests)
    if c == 0:
        return None
    dic0 = rests[0]
    return dict_to_task(dic0)


def query_all_task():
    sql = f'select * from t_task;'
    rests = mysql_pool.query(sql)
    c = len(rests)
    if c == 0:
        return None

    arr = []
    for dic in rests:
        entity = dict_to_task(dic)
        arr.append(entity)
    return arr


class Ui_MainWindow(QMainWindow):

    def __init__(self):
        super(Ui_MainWindow, self).__init__()

        self.work_dispatcher = TaskWorkerDispatcher()
        self.work_dispatcher.signals.next_worker.connect(self.on_update_task_worker)
        self.work_dispatcher.signals.finished.connect(self.on_connect_task_finish)


        self.worker_infos = dict()
        self.ui_wrap_infos = dict()
        self.task_infos = dict()
        self.task_items = []

        self.setupUi(self)
        self.setup_menu()

    def setup_menu(self):
        # 单击选中某一个选项
        self.listWidget.clicked.connect(self.on_check_row)

        # 窗口绑定右键事件
        self.window().setContextMenuPolicy(Qt.CustomContextMenu)
        self.window().customContextMenuRequested.connect(self.show_context_menu)

        # 创建QMenu
        self.contextMenu = QMenu(self)
        self.actionA = QAction("编辑")
        self.contextMenu.addAction(self.actionA)

        self.contextMenu.addSeparator()

        self.actionB = QAction("删除")
        self.contextMenu.addAction(self.actionB)

        self.contextMenu.addSeparator()

        self.actionC = QAction("导出")
        self.contextMenu.addAction(self.actionC)

        # 点击menu
        self.actionA.triggered.connect(self.on_menu_edit_task)
        self.actionB.triggered.connect(self.on_menu_rm_task)
        self.actionC.triggered.connect(self.on_menu_export_task)

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(840, 590)
        MainWindow.setMinimumSize(QtCore.QSize(840, 590))
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setMinimumSize(QtCore.QSize(100, 0))
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.toolButton_2 = QtWidgets.QToolButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.toolButton_2.sizePolicy().hasHeightForWidth())
        self.toolButton_2.setSizePolicy(sizePolicy)
        self.toolButton_2.setMinimumSize(QtCore.QSize(0, 30))
        self.toolButton_2.setObjectName("toolButton_2")
        self.horizontalLayout.addWidget(self.toolButton_2)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_2.sizePolicy().hasHeightForWidth())
        self.label_2.setSizePolicy(sizePolicy)
        self.label_2.setMinimumSize(QtCore.QSize(100, 40))
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_2.addWidget(self.label_2)
        self.toolButton = QtWidgets.QToolButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.toolButton.sizePolicy().hasHeightForWidth())
        self.toolButton.setSizePolicy(sizePolicy)
        self.toolButton.setMinimumSize(QtCore.QSize(0, 30))
        self.toolButton.setObjectName("toolButton")
        self.horizontalLayout_2.addWidget(self.toolButton)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.listWidget = QtWidgets.QListWidget(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.listWidget.sizePolicy().hasHeightForWidth())
        self.listWidget.setSizePolicy(sizePolicy)
        self.listWidget.setObjectName("listWidget")
        self.verticalLayout.addWidget(self.listWidget)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 840, 21))
        self.menubar.setObjectName("menubar")
        self.menu = QtWidgets.QMenu(self.menubar)
        self.menu.setObjectName("menu")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionNew_Task_2 = QtWidgets.QAction(MainWindow)
        self.actionNew_Task_2.setObjectName("actionNew_Task_2")
        self.menu.addAction(self.actionNew_Task_2)

        self.menu_import = QMenu(MainWindow)
        self.menu_import.setTitle("导入")

        self.action_import_data = QtWidgets.QAction(MainWindow)
        self.action_import_data.setText("Excel数据")
        self.menu_import.addAction(self.action_import_data)

        self.action_back_import = QtWidgets.QAction(MainWindow)
        self.menu_import.addSeparator()
        self.action_back_import.setText("任务")
        self.menu_import.addAction(self.action_back_import)

        self.menu.addSeparator()
        self.menu.addMenu(self.menu_import)


        self.menubar.addAction(self.menu.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "Chrome Driver"))
        self.toolButton_2.setText(_translate("MainWindow", "选择"))
        self.label_2.setText(_translate("MainWindow", "Proxy Tool"))
        self.toolButton.setText(_translate("MainWindow", "选择"))
        self.menu.setTitle(_translate("MainWindow", "工具"))
        self.actionNew_Task_2.setText(_translate("MainWindow", "New Task"))

        self.actionNew_Task_2.triggered.connect(self.on_open_new_task)
        self.action_import_data.triggered.connect(self.on_open_import_data)
        self.action_back_import.triggered.connect(self.on_open_import_back)

        self.toolButton.clicked.connect(self.open_chromedriver_file)
        self.toolButton_2.clicked.connect(self.open_proxy_file)

        # for i in range(0, 5):
        #     item_widget = QListWidgetItem()
        #     item_widget.setSizeHint(QSize(840, 300))
        #     self.listWidget.addItem(item_widget)
        #     wrap = get_task_cell(i)
        #     cell = wrap.widget
        #     self.listWidget.setItemWidget(item_widget, cell)
        #     print("开始绑定点击回调")
        #     wrap.start_btn.clicked.connect(self.on_click_start_task)

        # self.listWidget.resize(840, 1500)
        self.load_task_list()

    def load_task_list(self):

        self.ui_wrap_infos.clear()
        self.task_infos.clear()
        self.task_items.clear()
        self.listWidget.clear()

        task_arr = query_all_task()
        if task_arr is not None:
            for task in task_arr:
                self.display_task(task)

    def on_open_new_task(self):
        print("点击创建任务")
        dialog = TaskCreateDialog(callback=self.on_create_task)
        dialog.exec_()

    def on_open_import_data(self):
        DataImportDialog()

    def on_open_import_back(self):
        fileName, fileType = QtWidgets.QFileDialog.getOpenFileName(self.centralwidget, "选取文件", os.getcwd(),
                                                                   "All Files(*);;Text Files(*.txt)")

        if len(fileName) == 0:
            return
        with open(fileName, 'r') as f:
            txt = f.read()
            js_str = DataEncrypt.decrypt(txt)
            TaskImporter.import_str(js_str)
            alert_msg(self, '导入成功')
            self.load_task_list()


    def open_chromedriver_file(self):
        fileName, fileType = QtWidgets.QFileDialog.getOpenFileName(self.centralwidget, "选取文件", os.getcwd(),
                                                                   "All Files(*);;Text Files(*.txt)")

        if len(fileName) == 0:
            return
        self.toolButton.setText(fileName)
        print("选择Proxy Tool：" + fileName)

    def open_proxy_file(self):
        fileName, fileType = QtWidgets.QFileDialog.getOpenFileName(self.centralwidget, "选取文件", os.getcwd(),
                                                                   "All Files(*);;Text Files(*.txt)")
        if len(fileName) == 0:
            return
        self.toolButton_2.setText(fileName)
        print("选择Proxy Tool：" + fileName)

    def on_export_task_file(self, js_str):
        if js_str is None:
            return
        fileName, fileType = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, "选取文件", os.getcwd(), "All Files(*);;Text Files(*.txt)")
        if len(fileName) == 0:
            return

        rest = DataEncrypt.encrypt(js_str)
        with open(fileName, 'w') as f:
            f.write(rest)
            alert_msg(self, '导出成功')

    # 导出任务
    def on_menu_export_task(self):
        if self.f is None:
            return

        task = self.task_items[self.f]

        tid = task.tid
        js = TaskExporter.query_task(tid)
        data_str = TaskExporter.dump_2_json(js)
        print(f"导出任务:\n{data_str}")
        if data_str is not None:
            self.on_export_task_file(data_str)

    def on_menu_edit_task(self):
        if self.f is None:
            return
        print("点击右键菜单")
        # 获取到任务数据
        task = self.task_items[self.f]

        dialog = TaskCreateDialog(task_id=task.tid, callback=self.on_create_task)
        dialog.exec_()

    def on_menu_rm_task(self):
        if self.f is None:
            return
        print("点击删除任务")

        # 获取到任务数据
        task = self.task_items[self.f]

        # 删除数据
        self.task_infos[task.tid] = None
        self.ui_wrap_infos[task.tid] = None
        self.task_items.remove(task)

        rm_task(task.tid)

        # 更新界面
        self.listWidget.takeItem(self.f)

    def on_check_row(self, index):

        self.f = index.row()
        if self.f is None:
            return
        print(f"点击了行 {self.f}")

    def show_context_menu(self):

        items = self.listWidget.selectedItems()
        if len(items) > 0:
            # self.contextMenu.show()
            self.contextMenu.popup(QCursor.pos())  # 在鼠标位置显示
            self.contextMenu.show()

    def on_click_start_task(self):
        # print(f"开启任务 {self.sender().task}")
        tid: int = self.sender().task
        ui_wrap: TaskCellWrap = self.ui_wrap_infos[tid]
        task: TaskEntity = self.task_infos[tid]
        if task is None:
            alert_msg(self, "当前任务不存在")
            return

        worker = self.worker_infos.get(tid, None)
        is_running = False
        if worker is not None:
            is_running = worker.is_running

        if task.is_running == 0:
            if is_running:
                alert_msg(self, "当前任务仍在执行中，请稍后再试")
                return
            task.is_running = 1
        else:
            task.is_running = 0

        if ui_wrap is not None:
            ui_wrap.on_update_task(task)

        start_task(tid, task.is_running)

        if task.is_running == 0:
            self.stop_task(tid)
        else:
            self.run_task(tid)

    def on_update_task_worker(self, worker: TaskWorker):
        self.worker_infos[worker.tid] = worker
        self.work_dispatcher.start_task(worker)

    def run_task(self, tid):
        worker = self.worker_infos.get(tid, None)
        if worker is not None:
            if worker.is_running:  # 任务标记为结束了，但是实际上最后一条记录的执行还在继续
                alert_msg(self, "当前任务仍在执行中，请稍后再试")
                return

        worker = self.work_dispatcher.build_task_worker(tid)
        self.worker_infos[tid] = worker
        self.work_dispatcher.start_task(worker)

    def stop_task(self, tid):
        worker = self.worker_infos.get(tid, None)
        if worker is not None:

            worker.is_cancel = True
            if not worker.is_running:
                self.worker_infos[tid] = None

    def on_connect_task_finish(self, tid):
        ui_wrap: TaskCellWrap = self.ui_wrap_infos[tid]
        task: TaskEntity = self.task_infos[tid]
        if task is None:
            return

        task.is_running = 0
        if ui_wrap is not None:
            ui_wrap.on_update_task(task)
        start_task(tid, task.is_running)
        self.worker_infos[tid] = None

    def on_create_task(self, task: TaskCreateEntity, is_edit: bool):

        entity = query_task_by_tid(task.tid)
        if entity is None:
            return
        if is_edit:
            wrap = self.ui_wrap_infos[task.tid]
            self.task_infos[task.tid] = entity
            wrap.on_update_task(entity)
        else:
            self.display_task(entity)

    def display_task(self, task: TaskEntity):
        item_widget = QListWidgetItem()
        item_widget.setSizeHint(QSize(840, 300))
        self.listWidget.addItem(item_widget)
        wrap = get_task_cell(task.tid)
        wrap.on_update_task(task)
        cell = wrap.widget
        self.listWidget.setItemWidget(item_widget, cell)
        print("开始绑定点击回调")
        wrap.start_btn.clicked.connect(self.on_click_start_task)

        self.ui_wrap_infos[task.tid] = wrap
        self.task_infos[task.tid] = task
        self.task_items.append(task)


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)

    ui = Ui_MainWindow()
    ui.show()

    sys.exit(app.exec_())
